---
title: "Integrated Development Environments (or IDEs, for friends)"
date: 2026-01-17
page-layout: full
toc: false
description: "What is an IDE and why does it matter when starting to program in R? This text introduces the concept of an integrated development environment, explores common IDEs, and focuses on RStudio as a workspace designed for academic analysis. An invitation to understand the environment as a mediator between code, data, and research practices."
---

When someone starts programming, one of the first common confusions relates to the working environment. Where does the code "live"? Is it written in a common text file? Is it executed from a console (and what is a console)? Is R the same as RStudio? Do I have to [install](http://atelierdecodigo.com/en/posts/install-r-rstudio.html) both things? In what order? These questions are not minor, because they refer to a key distinction: the difference between a programming language and the environment in which that language is used. At this point, the notion of an **IDE** appears, short for *Integrated Development Environment*, or integrated development environment.

An IDE is a program that brings together several necessary programming tools in one space. Generally speaking, it combines at least four components: a code editor, a console where instructions are executed, tools for exploring files and objects, and aids for writing and reading code. The IDE does not replace the programming language, but rather offers a graphical interface that facilitates its use. R remains R, with its syntax and rules, regardless of the IDE used. However, the work experience changes substantially depending on the chosen environment.

There are widely used IDEs across different languages. [Visual Studio Code](https://code.visualstudio.com/) is one of the most popular today and is used for working with multiple languages, from R and Python to JavaScript. [Eclipse](https://eclipseide.org/) has a long tradition in Java development. [Spyder](https://www.spyder-ide.org/download) is common in the Python ecosystem, especially in scientific contexts. In the case of R, the most widespread IDE is **RStudio**, which was specifically designed to work with this language and with common data analysis practices. In recent years, [Positron](https://posit.co/products/ide/positron/) also appeared, an IDE developed by [Posit](https://posit.co/) that reuses many of RStudio's ideas and articulates them with a more generalist logic, oriented to working with multiple languages. However, in this series, we will focus on [RStudio](https://posit.co/products/open-source/rstudio/?sid=1) because it remains the most widespread environment in the academic use of R and because its design is deeply aligned with common practices of analysis, teaching, and reproducible writing in this language. And also because it's what we're used to :)

RStudio is organized into an interface that, at first glance, can be overwhelming: panels, tabs, buttons, windows. However, this arrangement responds to a work logic worth understanding. In one panel, you typically find the script editor, where code is written. In another, the console, which allows executing lines or blocks of code and immediately seeing their results. Other panels show the objects available in the session, project files, generated plots, or function documentation. This organization is not merely decorative. It proposes a way of thinking about data work as an activity distributed among writing, execution, exploration, and reading. In [this post](https://macarenaquiroga.com/en/post/help-i-have-quantitative-data/) there is a description of what each of these parts looks like. The important thing is to recognize each unit separately, because eventually the user can rearrange the position of the panels on their screen.

The script editor occupies a central place. There, the code is presented as text that can be read, reviewed, and modified. RStudio offers aids such as syntax highlighting, automatic indentation, and autocompletion, although it takes some time to understand these functionalities and incorporate them into daily practice. These features not only reduce technical errors but also facilitate code readability. Colors, indents, and suggestions make structures visible that would otherwise remain hidden in a uniform mass of characters. The IDE, in this sense, acts as a mediator that makes the language more legible. A script is, ultimately, a text.

We can think of the script editor as a word processor, like Word or GoogleDocs. The editor will mark with a red cross when something alters R's syntax (just as word processors underline words with spelling errors). Paying attention to errors is a very effective way to understand how the syntax of a programming language works.

In the console, we can execute functions directly, although they will not be saved unless we write them in the script (and this can cause problems if we lose track of our code). Working with the console can be useful when learning, because it enables constant testing, error, and reformulation, but the fact that the code and its results appear in the same place can hinder the clarity of our progress. The IDE does not force a linear path but accompanies back-and-forth processes between hypotheses, code, and results.

Another relevant aspect of RStudio is its integration with projects. Working on a project (a post on this is coming!) involves organizing files, data, scripts, and results within a coherent structure. This practice, which may seem excessive at first, becomes fundamental when analyses grow in complexity or when they are resumed after some time. The IDE facilitates this organization and, in doing so, promotes a more reflective and documented way of working. Code ceases to be something ephemeral that is executed once and lost, to become a record of the analytical process. This also fosters reproducibility, a crucial aspect of scientific practice.

RStudio also includes direct access to documentation, meaning the description and usage guide for functions and packages. When writing a function, it's possible to quickly consult what it does, what arguments it expects, and what it returns. For example, executing `?summary` in the console will yield the specific usage guide for that function. This proximity to help reinforces the idea that programming involves reading as much as writing. Functions are not used blindly; instead, they are interpreted, compared, and chosen based on what one wants to do with the data. No one knows everything by heart; instead, we constantly refer to the materials produced by those who created these functions.

It is important to emphasize that learning to use an IDE is not a prerequisite for "knowing how to program," but it is part of the technical literacy that accompanies language learning. The IDE shapes habits, reading modes, and ways of organizing work. In that sense, it is not neutral. RStudio, in particular, is designed for analytical practices typical of academic work: data exploration, reproducible writing, combining code and text, and producing plots and reports.

Thinking of the IDE as a mere technical support can lead to underestimating it. In reality, it functions as a workspace that embodies a certain conception of programming. For those starting with R from the social sciences and humanities, understanding what an IDE is and how it organizes the programming experience helps dismantle the idea that code is opaque or inaccessible. The environment is also read, interpreted, and learned to be used in a situated manner.

In the upcoming texts of this series, we will revisit RStudio in greater detail, observing how certain interface decisions interact with concrete analytical practices. Understanding the environment is a key step to start thinking of code as a language one works with, and not just as a tool that is executed.
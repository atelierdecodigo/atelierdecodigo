<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Atelier de código</title>
<link>https://atelierdecodigo.com/posts/</link>
<atom:link href="https://atelierdecodigo.com/posts/index.xml" rel="self" type="application/rss+xml"/>
<description></description>
<generator>quarto-1.8.27</generator>
<lastBuildDate>Thu, 29 Jan 2026 03:00:00 GMT</lastBuildDate>
<item>
  <title>¿Qué es la programación orientada a objetos y por qué R se considera un lenguaje orientado a objetos?</title>
  <link>https://atelierdecodigo.com/posts/lenguaje-orientado-objetos.html</link>
  <description><![CDATA[ 




<p>Cuando se empieza a programar, muchas de las operaciones parecen simples instrucciones que se ejecutan en secuencia: cargar datos, aplicar una función, obtener un resultado. A medida que los proyectos crecen, aparece otra necesidad: organizar el código y los datos de forma que sea más fácil de entender, reutilizar y extender. La <strong>programación orientada a objetos (POO)</strong> surge como una respuesta a ese problema de organización.</p>
<p>Pensar en orientación a objetos implica cambiar ligeramente el foco. En lugar de concentrarse solo en acciones, se pone atención en las entidades sobre las que se actúa y en las relaciones entre datos y operaciones. Esta forma de estructurar el código no es exclusiva de un lenguaje, sino una manera de modelar problemas.</p>
<section id="la-idea-central-de-la-orientación-a-objetos" class="level3">
<h3 class="anchored" data-anchor-id="la-idea-central-de-la-orientación-a-objetos">La idea central de la orientación a objetos</h3>
<p>En términos generales, la programación orientada a objetos se basa en el concepto de <strong>objeto</strong>. Un objeto combina dos cosas: datos y las operaciones que tienen sentido para esos datos. Por ejemplo, un conjunto de datos puede tener asociadas operaciones para resumirse, graficarse o transformarse.</p>
<p>Los objetos suelen pertenecer a una clase, que define qué tipo de datos contienen y qué operaciones se pueden aplicar. A partir de una clase se crean objetos concretos. Esta separación permite trabajar con abstracciones: no hace falta conocer todos los detalles internos para usar un objeto de manera consistente.</p>
<p>Otro concepto importante es el de método, que es una función asociada a una clase específica. En lugar de pensar que una función existe de forma aislada, se la entiende como una operación que se aplica a un tipo particular de objeto.</p>
</section>
<section id="por-qué-esta-lógica-resulta-útil" class="level3">
<h3 class="anchored" data-anchor-id="por-qué-esta-lógica-resulta-útil">Por qué esta lógica resulta útil</h3>
<p>La orientación a objetos ayuda a manejar la <strong>complejidad</strong>. Permite escribir código que se adapta a distintos tipos de datos sin reescribirse por completo, facilita la extensión de funcionalidades y promueve cierta coherencia interna. Para quien lee el código, también ofrece pistas sobre qué operaciones son esperables para cada tipo de objeto.</p>
<p>Esta forma de organizar el trabajo es especialmente valiosa en lenguajes usados para análisis de datos, donde conviven tablas, modelos estadísticos, gráficos y resultados intermedios. Cada uno de estos elementos puede pensarse como un objeto con comportamientos propios.</p>
</section>
<section id="r-como-lenguaje-orientado-a-objetos" class="level3">
<h3 class="anchored" data-anchor-id="r-como-lenguaje-orientado-a-objetos">R como lenguaje orientado a objetos</h3>
<p>R es un lenguaje orientado a objetos, aunque no siempre se lo perciba de ese modo al comenzar a usarlo. Esto se debe a que R implementa la orientación a objetos de una manera particular, menos explícita que en otros lenguajes como Java o Python.</p>
<p>En R, casi todo es un objeto. Un vector, un data frame, un modelo estadístico o un gráfico son objetos con una clase asociada. Esa clase define cómo se comportan frente a ciertas funciones. Por ejemplo, la función summary() produce resultados distintos según el tipo de objeto que recibe. El mismo nombre de función activa métodos diferentes según la clase del objeto de entrada.</p>
<p>Este mecanismo se conoce como despacho de métodos. En lugar de llamar a una función específica para cada tipo de dato, R decide internamente qué método usar. Para quien analiza datos, esto reduce la carga cognitiva: se usan las mismas funciones generales y el comportamiento se ajusta al objeto.</p>
</section>
<section id="los-sistemas-de-objetos-en-r" class="level3">
<h3 class="anchored" data-anchor-id="los-sistemas-de-objetos-en-r">Los sistemas de objetos en R</h3>
<p>R tiene varios sistemas de objetos. Los más conocidos son S3 y S4, y más recientemente R6. S3 es un sistema flexible e informal, muy extendido en paquetes y en el uso cotidiano. S4 es más estricto y define de forma explícita la estructura de las clases. R6 se parece más a la orientación a objetos clásica, con objetos mutables.</p>
<p>Para empezar, no es necesario dominar estos sistemas en detalle. Lo importante es reconocer que cuando se trabaja con data frames, modelos o gráficos, se está interactuando con objetos que responden a reglas específicas según su clase.</p>
</section>
<section id="leer-código-desde-esta-perspectiva" class="level3">
<h3 class="anchored" data-anchor-id="leer-código-desde-esta-perspectiva">Leer código desde esta perspectiva</h3>
<p>Entender que R es un lenguaje orientado a objetos ayuda a leer mejor el código. Permite preguntarse qué tipo de objeto se tiene entre manos, qué operaciones son coherentes con ese objeto y por qué una función se comporta de cierta manera. Esta mirada vuelve más predecible el análisis y facilita el aprendizaje de nuevos paquetes.</p>
<p>La orientación a objetos en R no exige escribir clases desde el primer día. Funciona, en muchos casos, como una infraestructura silenciosa que organiza el lenguaje. Reconocer su presencia ayuda a pasar de ejecutar código a interpretarlo como parte de un sistema más amplio.</p>


</section>

 ]]></description>
  <guid>https://atelierdecodigo.com/posts/lenguaje-orientado-objetos.html</guid>
  <pubDate>Thu, 29 Jan 2026 03:00:00 GMT</pubDate>
</item>
<item>
  <title>¿Qué es la ciencia de datos y por qué tanto interés?</title>
  <link>https://atelierdecodigo.com/posts/que-es-ciencia-de-datos.html</link>
  <description><![CDATA[ 




<p>En los últimos años, la expresión <em>ciencia de datos</em> se volvió omnipresente. Aparece en ofertas laborales, programas académicos, proyectos de investigación y debates públicos. A veces se la presenta como una disciplina nueva y homogénea; otras, como un conjunto difuso de técnicas. Para entender de qué se trata, conviene situarla históricamente, revisar sus vínculos con la estadística y el big data, y pensar por qué resulta especialmente atractiva para quienes vienen de tradiciones analíticas vinculadas a lo social.</p>
<section id="un-origen-ligado-a-problemas-concretos" class="level3">
<h3 class="anchored" data-anchor-id="un-origen-ligado-a-problemas-concretos">Un origen ligado a problemas concretos</h3>
<p>La ciencia de datos no surge de un solo campo ni en un momento preciso. Se consolida a partir de la convergencia de prácticas que ya existían: el análisis estadístico, la programación, la gestión de bases de datos y el trabajo con grandes volúmenes de información. A mediados del siglo XX, la estadística aplicada ya cumplía un rol central en la investigación científica y en la toma de decisiones. Más adelante, con la expansión de la computación y el almacenamiento digital, comenzó a ser posible trabajar con conjuntos de datos cada vez más grandes y complejos.</p>
<p>El término <em>data science</em> empieza a circular con más fuerza hacia fines de los años noventa y principios de los dos mil, cuando se vuelve evidente que los problemas ya no pasan solo por calcular indicadores, sino por organizar, limpiar, transformar e interpretar datos heterogéneos. La ciencia de datos se configura así como una respuesta práctica a una pregunta recurrente: cómo producir conocimiento a partir de datos en contextos donde el volumen, la variedad y la velocidad de la información desafían los enfoques tradicionales.</p>
<section id="ciencia-de-datos-y-estadística" class="level4">
<h4 class="anchored" data-anchor-id="ciencia-de-datos-y-estadística">Ciencia de datos y estadística</h4>
<p>La relación entre ciencia de datos y estadística es estrecha, aunque no siempre evidente. Muchas de las herramientas centrales de la ciencia de datos, como la estimación, la inferencia o la modelización, provienen directamente de la estadística. Sin embargo, la ciencia de datos amplía el foco. Además de analizar datos ya preparados, se ocupa de todo el proceso: desde la obtención de la información hasta la comunicación de resultados.</p>
<p>En este sentido, programar ocupa un lugar clave. No solo como medio para ejecutar cálculos, sino como forma de describir procedimientos de manera explícita y reproducible. El código permite documentar decisiones, repetir análisis y ajustar pasos intermedios. La estadística aporta los marcos conceptuales para interpretar los resultados, mientras que la programación articula esos marcos con datos concretos y flujos de trabajo complejos.</p>
</section>
<section id="el-vínculo-con-el-big-data" class="level4">
<h4 class="anchored" data-anchor-id="el-vínculo-con-el-big-data">El vínculo con el big data</h4>
<p>El big data suele aparecer asociado a la ciencia de datos, aunque no son sinónimos. El big data se refiere, en términos generales, a conjuntos de datos de gran tamaño o alta complejidad, que requieren infraestructuras específicas para su almacenamiento y procesamiento. La ciencia de datos puede trabajar con big data, pero también con bases pequeñas, encuestas, registros administrativos o corpus textuales.</p>
<p>Lo que comparten es una preocupación común: cómo transformar datos en información significativa. En muchos casos, el desafío no está en la cantidad de datos, sino en su calidad, su estructura y su contexto de producción. Desde esta perspectiva, la ciencia de datos no se define solo por el volumen, sino por una forma de abordar el análisis que integra técnica, interpretación y toma de decisiones.</p>
</section>
<section id="por-qué-despierta-interés-en-las-ciencias-sociales" class="level4">
<h4 class="anchored" data-anchor-id="por-qué-despierta-interés-en-las-ciencias-sociales">Por qué despierta interés en las ciencias sociales</h4>
<p>El creciente interés de personas formadas en disciplinas sociales por la ciencia de datos tiene varias razones. En primer lugar, muchas investigaciones contemporáneas trabajan con datos digitales: encuestas en línea, bases administrativas, redes sociales, archivos textuales o registros de interacción. Estos materiales requieren herramientas que permitan explorarlos y analizarlos de manera sistemática.</p>
<p>En segundo lugar, la ciencia de datos propone un modo de trabajo que dialoga bien con preocupaciones clásicas del análisis social. La necesidad de explicitar supuestos, documentar procedimientos y reflexionar sobre las categorías utilizadas encuentra un aliado en el uso de código y flujos reproducibles. El análisis deja rastros que pueden ser leídos, discutidos y revisados.</p>
<p>Además, la ciencia de datos pone en primer plano preguntas sobre el poder de los datos, los sesgos, la representatividad y los usos sociales de la información. Estas preguntas no son ajenas a las tradiciones críticas de las ciencias sociales. Al contrario, ofrecen un espacio donde herramientas técnicas y reflexión conceptual se encuentran.</p>
</section>
<section id="una-práctica-situada" class="level4">
<h4 class="anchored" data-anchor-id="una-práctica-situada">Una práctica situada</h4>
<p>Más que una disciplina cerrada, la ciencia de datos puede entenderse como una práctica situada. Sus herramientas se adaptan a problemas específicos y a contextos concretos de investigación, trabajo o intervención. Aprender ciencia de datos implica aprender a formular preguntas, a evaluar fuentes, a tomar decisiones metodológicas y a comunicar resultados de forma responsable.</p>
<p>Desde esta mirada, programar, analizar y visualizar datos no son fines en sí mismos. Son medios para construir conocimiento en diálogo con marcos teóricos, preguntas sustantivas y condiciones materiales de producción. La ciencia de datos se vuelve así un espacio fértil para quienes buscan articular técnica y reflexión, sin perder de vista que los datos siempre están anclados en prácticas sociales.</p>


</section>
</section>

 ]]></description>
  <guid>https://atelierdecodigo.com/posts/que-es-ciencia-de-datos.html</guid>
  <pubDate>Wed, 28 Jan 2026 03:00:00 GMT</pubDate>
</item>
<item>
  <title>6 libros imprescindibles para aprender Ciencia de Datos</title>
  <link>https://atelierdecodigo.com/posts/libros-aprender-ciencia-datos.html</link>
  <description><![CDATA[ 




<p>Profundizar en ciencia de datos va más allá de aprender sintaxis o ejecutar comandos. Leer libros que articulan conceptos, técnicas y reflexiones ayuda a entender el campo en conjunto. Afortunadamente, existen textos accesibles de forma gratuita en la web que cubren desde fundamentos hasta aplicaciones concretas. A continuación presento cinco libros recomendados, de acceso libre. Algunos están en inglés, otros en español.</p>
<section id="r-for-data-science-hadley-wickham-garrett-grolemund-y-mine-çetinkaya-rundel" class="level4">
<h4 class="anchored" data-anchor-id="r-for-data-science-hadley-wickham-garrett-grolemund-y-mine-çetinkaya-rundel"><a href="https://r4ds.hadley.nz/">1. <em>R for Data Science</em> (Hadley Wickham, Garrett Grolemund y Mine Çetinkaya-Rundel)</a></h4>
<p>Este libro es el fundamento absoluto sobre la programación en R en el mundo de la ciencia de datos. Abarca temas como la limpieza y la visualización de datos, entre otros temas. Está pensado para quien recién empieza, pero con un nivel de detalle que permite seguir aprendiendo de forma continua. Tiene su versión en español <a href="https://davidrsch.github.io/r4ds-es/">aquí</a>.</p>
</section>
<section id="telling-stories-with-data-rohan-alexander" class="level4">
<h4 class="anchored" data-anchor-id="telling-stories-with-data-rohan-alexander"><a href="https://rohanalexander.github.io/telling_stories-published/">2. <em>Telling Stories with Data</em> (Rohan Alexander)</a></h4>
<p>Enfocado en la comunicación estadística y la narrativa de los análisis, este libro cubre desde la recopilación y limpieza de datos hasta la presentación de resultados. Incluye ejemplos de código y actividades que refuerzan la comprensión de cada técnica. Su enfoque en cómo traducir datos en conclusiones claras lo hace especialmente útil para quienes trabajan con análisis interpretativos.</p>
</section>
<section id="libro-vivo-de-ciencia-de-datos-pablo-casas" class="level4">
<h4 class="anchored" data-anchor-id="libro-vivo-de-ciencia-de-datos-pablo-casas"><a href="https://librovivodecienciadedatos.ai/">3. <em>Libro Vivo de Ciencia de Datos</em> (Pablo Casas)</a></h4>
<p>Este libro en español presenta una introducción intuitiva a la ciencia de datos y al machine learning, con un enfoque didáctico. Propone una visión práctica de cómo pensar y trabajar con datos desde niveles iniciales.</p>
</section>
<section id="deep-r-programming-marek-gagolewski" class="level4">
<h4 class="anchored" data-anchor-id="deep-r-programming-marek-gagolewski"><a href="https://deepr.gagolewski.com/index.html">4. <em>Deep R Programming</em> (Marek Gagolewski)</a></h4>
<p>Aunque más técnico, este recurso gratuito ofrece una introducción profunda al lenguaje R desde la perspectiva de la ciencia de datos. El libro cubre transformaciones de datos, cálculo numérico, programación funcional y estructuras avanzadas, con ejemplos y ejercicios prácticos.</p>
</section>
<section id="openintro-statistics-david-diez-christopher-barr-y-mine-çetinkaya-rundel" class="level4">
<h4 class="anchored" data-anchor-id="openintro-statistics-david-diez-christopher-barr-y-mine-çetinkaya-rundel"><a href="https://www.biostat.jhsph.edu/~iruczins/teaching/books/2019.openintro.statistics.pdf">5. <em>OpenIntro Statistics</em> (David Diez, Christopher Barr y Mine Çetinkaya-Rundel)</a></h4>
<p>Aunque este texto es un libro de estadística, es una lectura esencial para ciencia de datos. La estadística es un pilar del análisis de datos, y este libro acompaña al lector desde los conceptos básicos hasta técnicas aplicadas.</p>
</section>
<section id="learning-statistics-with-r-danielle-navarro" class="level3">
<h3 class="anchored" data-anchor-id="learning-statistics-with-r-danielle-navarro"><a href="https://learningstatisticswithr.com/">6. Learning Statistics with R (Danielle Navarro)</a></h3>
<p>Este libro en inglés recopila los materiales de un curso de introducción a la estadística que la autora dio en la Universidad de Adelaide, con ejemplos en R. Condensa no solamente la teoría sino también la práctica para llevar adelante un análisis de datos real e informado. Además, Danielle es una persona muy activa en la comunidad de R y sus aportes son realmente fundamentales.</p>
</section>
<section id="cómo-usar-estos-libros-en-tu-aprendizaje" class="level3">
<h3 class="anchored" data-anchor-id="cómo-usar-estos-libros-en-tu-aprendizaje">Cómo usar estos libros en tu aprendizaje</h3>
<p>Estos textos sirven distintos propósitos: algunos introducen conceptos generales, otros profundizan en herramientas específicas y otros integran programación y análisis. Una estrategia de lectura efectiva puede combinar un libro más conceptual con materiales prácticos que incluyan ejercicios de código y casos reales.</p>
<p>Si estás comenzando, puede ser útil empezar por capítulos introductorios (por ejemplo, fundamentos de ciencia de datos y comunicación de resultados) antes de avanzar hacia textos más técnicos o centrados en lenguajes específicos como R.</p>


</section>

 ]]></description>
  <guid>https://atelierdecodigo.com/posts/libros-aprender-ciencia-datos.html</guid>
  <pubDate>Tue, 27 Jan 2026 03:00:00 GMT</pubDate>
</item>
<item>
  <title>Gramática de gráficos</title>
  <link>https://atelierdecodigo.com/posts/gramatica-graficos-ggplot.html</link>
  <description><![CDATA[ 




<section id="la-gramática-de-los-gráficos-pensar-la-visualización-como-un-lenguaje" class="level3">
<h3 class="anchored" data-anchor-id="la-gramática-de-los-gráficos-pensar-la-visualización-como-un-lenguaje">La gramática de los gráficos: pensar la visualización como un lenguaje</h3>
<p>Los gráficos ocupan un lugar central en el análisis de datos. Se los usa para explorar patrones, comunicar resultados y sostener argumentos. Sin embargo, muchas veces se los piensa como un producto final, algo que se “elige” entre un conjunto de opciones disponibles. La idea de una <strong>gramática de los gráficos</strong> propone un desplazamiento: los gráficos se pueden entender como construcciones compuestas por partes o <em>capas</em>, organizadas según reglas relativamente estables, de forma comparable a cómo funcionan los lenguajes.</p>
<p>En lugar de preguntar “qué tipo de gráfico hago”, la pregunta pasa a ser <a href="https://macarenaquiroga.com/post/como-elegir-un-tipo-de-grafico-en-funcion-de-las-preguntas-de-investigacion/">“qué quiero transmitir”</a>. Eso nos va a permitir pensar qué relaciones queremos representar y qué elementos necesitamos combinar para hacerlo visible. La visualización deja de ser decorativa y se integra al razonamiento analítico.</p>
<section id="qué-se-entiende-por-gramática-de-los-gráficos" class="level4">
<h4 class="anchored" data-anchor-id="qué-se-entiende-por-gramática-de-los-gráficos">Qué se entiende por gramática de los gráficos</h4>
<p>El concepto de gramática de los gráficos fue desarrollado por Leland Wilkinson en su libro <a href="https://link.springer.com/chapter/10.1007/978-3-642-21551-3_13"><em>The Grammar of Graphics</em></a> y parte de una idea sencilla: cualquier gráfico estadístico puede descomponerse en componentes básicos. Entre ellos se encuentran los datos, las variables que se mapean a propiedades visuales, las formas geométricas que representan esos datos y las escalas que traducen valores a posiciones, colores o tamaños.</p>
<p>Desde este enfoque, un gráfico no es un objeto indivisible, sino el resultado de una serie de decisiones explícitas. Qué variable va en el eje horizontal, cuál en el vertical, si los valores se representan con puntos, barras o líneas, cómo se agrupan las observaciones. Cada una de estas elecciones forma parte de la estructura del gráfico y afecta su interpretación.</p>
</section>
<section id="la-gramática-de-los-gráficos-en-ggplot2" class="level4">
<h4 class="anchored" data-anchor-id="la-gramática-de-los-gráficos-en-ggplot2">La gramática de los gráficos en ggplot2</h4>
<p>Hadley Wickham retoma este concepto en su artículo <a href="https://www.tandfonline.com/doi/abs/10.1198/jcgs.2009.07098"><em>A Layered Grammar of Graphics</em></a>y presenta su paquete <code>ggplot2</code> que implementa esta idea de manera directa. Para construir un gráfico, se parte de un conjunto de datos y se van agregando capas, cada una con una función específica. El código refleja esta lógica composicional y permite leer el gráfico como una secuencia de decisiones.</p>
<p>Un ejemplo mínimo puede ilustrar esta estructura:</p>
<pre><code>ggplot(data = datos, aes(x = edad, y = ingreso)) +
  geom_point()</code></pre>
<p>En este fragmento aparecen varios componentes clave. <code>ggplot()</code> define el conjunto de datos y el mapeo básico, es decir, qué variables se asocian a qué dimensiones visuales. <code>geom_point()</code> agrega una geometría concreta, en este caso puntos. Si quisiéramos cambiar la forma de representación, podríamos reemplazar o sumar geometrías sin rehacer todo el gráfico.</p>
<p>Esta forma de trabajar favorece la experimentación controlada. Es posible modificar una sola parte del gráfico y observar cómo cambia el resultado. También facilita comparar visualizaciones que comparten una estructura común, lo que resulta especialmente útil en análisis exploratorios.</p>
</section>
<section id="visualizar-como-parte-del-análisis" class="level4">
<h4 class="anchored" data-anchor-id="visualizar-como-parte-del-análisis">Visualizar como parte del análisis</h4>
<p>Pensar la visualización como un lenguaje implica reconocer que los gráficos no son neutrales. Cada gráfico enfatiza ciertas relaciones y deja otras en segundo plano. La gramática de los gráficos obliga a explicitar estas elecciones, tanto en el código como en el razonamiento que lo acompaña.</p>
<p>En contextos de análisis social, esta explicitación es relevante. Visualizar distribuciones, comparar grupos o seguir evoluciones temporales supone definir categorías, escalas y unidades de análisis. La gramática de los gráficos ofrece un marco para hacer visibles estas decisiones y para discutirlas.</p>
<p>Además, al trabajar con código, el gráfico se vuelve reproducible y revisable. Otras personas pueden leer cómo fue construido, modificarlo o adaptarlo a nuevas preguntas. La visualización deja de ser un cierre del análisis y pasa a formar parte del proceso.</p>
</section>
<section id="una-herramienta-para-aprender-a-leer-gráficos" class="level4">
<h4 class="anchored" data-anchor-id="una-herramienta-para-aprender-a-leer-gráficos">Una herramienta para aprender a leer gráficos</h4>
<p>La gramática de los gráficos no solo sirve para producir visualizaciones, sino también para leerlas críticamente. Identificar qué variables están siendo comparadas, qué escalas se usan y qué geometrías intervienen permite evaluar mejor un gráfico ajeno y entender qué muestra y qué oculta.</p>
<p>Desde esta perspectiva, aprender <code>ggplot2</code> no es solo aprender una sintaxis. Es incorporar una manera de pensar la visualización como práctica analítica situada, con reglas, posibilidades y límites. En los próximos posts de la serie vamos a trabajar con ejemplos concretos para ver cómo esta gramática se pone en juego en gráficos habituales del análisis de datos.</p>


</section>
</section>

 ]]></description>
  <guid>https://atelierdecodigo.com/posts/gramatica-graficos-ggplot.html</guid>
  <pubDate>Mon, 26 Jan 2026 03:00:00 GMT</pubDate>
</item>
<item>
  <title>Proyectos en RStudio y control de versiones: trabajar sin perderse en archivos</title>
  <link>https://atelierdecodigo.com/posts/proyectos-control-versiones-github.html</link>
  <description><![CDATA[ 




<p>Quienes empiezan a trabajar con datos suelen hacerlo a partir de archivos sueltos. Un script que se llama <code>analisis_final.R</code>, luego otro <code>analisis_final_v2.R</code>, después <code>analisis_final_ahora_si.R</code>. Cuando el trabajo avanza, aparecen copias en distintos dispositivos, versiones enviadas por mail y carpetas duplicadas. Si además participan varias personas, la situación se vuelve rápidamente confusa: no queda claro cuál es el archivo más actualizado, qué cambios hizo cada quien o qué versión se usó para obtener un resultado.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://atelierdecodigo.com/posts/images/memeversionfinal.jpg" class="img-fluid figure-img" alt="Una imagen de una carpeta donde hay archivos de word llamados &quot;Documento final&quot;, &quot;Documento final 2&quot;, &quot;Documento finalmente definitivo&quot; y así."></p>
<figcaption>Dale, ¿quién no estuvo en esta situación?</figcaption>
</figure>
</div>
<p>Una respuesta habitual a este problema es mover todo a la nube. Servicios como Google Drive o Dropbox permiten que los archivos estén disponibles desde distintos lugares y dispositivos. Esto resuelve parte del inconveniente, porque reduce la circulación de copias desconectadas entre sí. Sin embargo, sigue quedando una pregunta importante abierta: cómo registrar los cambios a lo largo del tiempo, volver atrás si algo sale mal o entender qué se modificó entre una versión y otra de un mismo archivo.</p>
<p>Ahí es donde entra el control de versiones, y en particular plataformas como <a href="https://github.com/">GitHub</a><sup>1</sup>. El control de versiones permite guardar la historia de un proyecto, registrar cada cambio de manera ordenada y trabajar de forma coordinada sin pisarse el trabajo. GitHub agrega a esto una infraestructura en la nube que facilita compartir proyectos, colaborar y mantener una referencia clara de qué versión es la vigente. En lugar de intercambiar archivos terminados, se trabaja sobre un mismo proyecto, con un registro explícito de su evolución.</p>
<p>En pocas palabras, el funcionamiento de git es el siguiente: tenemos un repositorio (podemos pensarlo como una carpeta alojada en la nube) de la cual nos descargamos una copia en nuestra computadora. Realizamos cambios a ese repositorio, pero mientras no hagamos nada más, la versión que está en la nube (en Github) va a seguir como antes. Una vez que terminamos de trabajar o llegamos a un resultado satisfactorio, “subimos” esos cambios a ese repositorio y el que estaba en la nube se actualiza (y tanto el repositorio en la nube como el que tenemos en nuestra computadora van a ser idénticos).</p>
<p>Distintas personas pueden trabajar con un mismo repositorio y “subir” sus cambios, siempre y cuando esos cambios no entren en conflicto. Cuando esto ocurre (y va a ocurrir, camaradas, inevitablemente), git nos permite saber dónde se da ese conflicto, cuáles fueron las versiones que entraron en conflicto (“hasta la versión 4 estaba todo bien, en la 5 de Pepito ya se pudrió todo”) y nos da la posibilidad de retrotraer los cambios hasta una versión previa (o aceptar a la fuerza los cambios). Lo bueno es que git guarda registro de todo, lo cual nos puede sacar de un apuro más de una vez.</p>
<section id="crear-un-proyecto-de-rstudio-conectado-a-github" class="level3">
<h3 class="anchored" data-anchor-id="crear-un-proyecto-de-rstudio-conectado-a-github">Crear un proyecto de RStudio conectado a GitHub</h3>
<p>Rstudio ya trae incorporada una funcionalidad que permite integrar nuestros proyectos con un repositorio de Github. Para combinar RStudio con control de versiones, el punto de partida sigue siendo un <a href="https://atelierdecodigo.com/posts/proyectos-rstudio.html">proyecto</a>. La diferencia es que ese proyecto estará asociado desde el inicio a un repositorio.</p>
<ol type="1">
<li><p><strong>Crear un repositorio en GitHub</strong> Ingresá a tu cuenta de GitHub y creá un repositorio nuevo, haciendo click en el botón verde que está arriba a la derecha, <em>New</em>.</p>
<p><img src="https://atelierdecodigo.com/posts/images/CleanShot 2026-01-21 at 22.47.36@2x.png" class="img-fluid"></p>
<p>Elegí un nombre sencillo y marcá la opción de inicializarlo con un archivo <code>README.md</code>. Copiá la URL del repositorio, que la vamos a usar en el siguiente paso.</p></li>
<li><p><strong>Crear el proyecto desde RStudio</strong> En RStudio, andá a <em>File &gt; New Project</em>. Elegí la opción <em>Version Control</em> y luego <em>Git</em>. Pegá la URL del repositorio de GitHub y seleccioná la carpeta local donde querés que se descargue el proyecto. Al aceptar, RStudio crea una carpeta que ya incluye el vínculo con el repositorio.</p></li>
<li><p><strong>Reconocer el entorno de trabajo</strong> Una vez creado el proyecto, vas a notar un panel nuevo en RStudio llamado <em>Git</em>. Desde ahí se pueden ver los archivos modificados, guardar cambios y enviarlos al repositorio remoto. A partir de este momento, todo el trabajo debería hacerse dentro de esta carpeta del proyecto.</p></li>
<li><p><strong>Guardar y registrar cambios</strong> Acá tenés dos formas distintas para subir los cambios: una es a través de la interfaz gráfica integrada en RStudio y la otra es a través de la terminal también integrada a Rstudio. Para la primera versión, tenés que identificar la solapa que dice “Git”, al lado de “Environmente” y de “History”. Cuando editás un script o agregás un archivo, RStudio marca esos cambios en el panel <em>Git</em>. Para subirlos al repositorio, seleccionás los archivos en la columna <em>Staged</em>, hacés click en el botón <em>Commit</em> (aquí escribís un mensaje breve que describa qué hiciste) y confirmás el cambio. Ese registro queda guardado como parte de la historia del proyecto. Finalmente, hacés click en <em>Push</em> y se suben los archivos. La próxima vez que empieces a trabajar, tenés que hacer “Pull” para asegurarte de bajar en tu repositorio local todos los cambios que otras personas (o vos en otro dispositivo) hayan hecho.</p>
<p>La segunda forma es a través de la terminal, que está al lado de la solapa “Console”. La lógica es la misma: seleccionás los archivos, le agregás un mensaje descriptivo que indique lo que hiciste (el <em>commit</em>) y luego los subís. La diferencia es que lo hacés con comandos:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1">git add .</span>
<span id="cb1-2">git commit <span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>m <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"mensaje descriptivo"</span></span>
<span id="cb1-3">git push</span>
<span id="cb1-4"></span>
<span id="cb1-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># la próxima vez que retomes el trabajo</span></span>
<span id="cb1-6">git pull</span></code></pre></div></div>
</div>
<p>Cada vez que escribís un comando, hacés <em>enter</em> para ejecutarlo. En mi experiencia, es más rápido y sencillo que usar la interfaz gráfica de RStudio, pero es cuestión de gustos.</p></li>
</ol>
<p>Este flujo permite trabajar de manera más ordenada y transparente. Cada decisión queda registrada, los errores pueden revertirse y el proyecto se convierte en un espacio compartido con memoria.</p>
<p>Trabajar con proyectos y control de versiones no es solo una cuestión técnica. Es una forma de organizar el trabajo intelectual, de hacerlo más legible y de reducir la fricción cuando se colabora con otras personas. Debemos advertirte que, como dijo <a href="https://es.wikipedia.org/wiki/T%C3%ADo_Ben">el tío Ben</a>, un gran poder viene con una gran responsabilidad, y es normal encontrarse con errores a la hora de usar git (sobre todo si usamos varios dispositivos y nos olvidamos de actualizar los cambios). Existen muchísimos comandos para miles de situaciones y aprietes en los que te podés encontrar, por lo cual te sugiero tener a mano guías como <a href="https://rogerdudler.github.io/git-guide/index.es.html">esta</a> o incluso este curso de <a href="https://www.freecodecamp.org/espanol/news/guia-para-principiantes-de-git-y-github/">FreeCodeCamp</a>.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Si bien acá vamos a hablar de Github, en rigor de verdad una cosa es <em>Git</em> y otra cosa es <em>Github</em>. <strong>git</strong> es el sistema de control de versiones que se instala localmente y se encarga de registrar los cambios en los archivos, algo así como la tecnología que permite el seguimiento de los cambios. <strong>GitHub</strong>, <strong>GitLab</strong> y plataformas similares son servicios que alojan repositorios git en la nube y agregan herramientas para compartir, colaborar y gestionar proyectos.↩︎</p></li>
</ol>
</section></div> ]]></description>
  <guid>https://atelierdecodigo.com/posts/proyectos-control-versiones-github.html</guid>
  <pubDate>Sat, 24 Jan 2026 03:00:00 GMT</pubDate>
</item>
<item>
  <title>Reproducibilidad: por qué importa y qué tiene que ver con programar bien</title>
  <link>https://atelierdecodigo.com/posts/reproducibilidad.html</link>
  <description><![CDATA[ 




<p>En muchas áreas de investigación, los resultados no se producen de una sola vez. Se construyen a partir de datos, decisiones analíticas, ajustes, correcciones y vueltas atrás. En ese proceso, una pregunta aparece tarde o temprano: ¿otra persona podría obtener los mismos resultados siguiendo los mismos pasos? A esa posibilidad se la suele llamar <a href="https://blog.scielo.org/es/2023/06/02/reproduccion-replicacion-en-investigacion-cientifica-parte-2/">reproducibilidad</a>.</p>
<p>La reproducibilidad se refiere a la capacidad de repetir un análisis y llegar a los mismos resultados usando los mismos datos y los mismos procedimientos. No implica que los resultados sean universales ni definitivos, sino que el camino que llevó a ellos sea claro y verificable. En términos prácticos, un análisis reproducible permite entender qué se hizo, cómo se hizo y en qué orden.</p>
<p>La falta de reproducibilidad rara vez se debe a mala intención (<a href="https://datacolada.org/118">aunque a veces ocurre</a>). Más bien suele estar asociada a prácticas habituales pero poco sistemáticas: archivos de datos modificados sin registro, análisis hechos parcialmente en la consola, pasos intermedios que no se guardan, resultados copiados y pegados en documentos finales. Con el tiempo, incluso quien realizó el análisis puede perder la capacidad de reconstruirlo.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://atelierdecodigo.com/posts/images/spidermanmeme.jpg" class="img-fluid figure-img" alt="Meme donde se ve a dos Spiderman señalándose entre sí."></p>
<figcaption>Cuando buscamos al culpable de que nuestro código ya no funcione tan solo unos meses después de haberlo escrito.</figcaption>
</figure>
</div>
<p>En este punto, la programación cumple un rol central. Trabajar con código permite dejar registro explícito de cada decisión. Un script puede cómo se cargaron los datos, qué transformaciones se aplicaron, qué modelos se ajustaron y cómo se produjeron los resultados, tanto tablas como gráficos. Ese registro no depende de la memoria ni de explicaciones posteriores. Está escrito y puede leerse, ya sea en texto plano usando un archivo RMarkdown o Quarto, o en los comentarios del propio código.</p>
<p>Las <a href="https://rpubs.com/reyzaguirre/125657">buenas prácticas de programación</a> refuerzan esta lógica. Escribir código en <a href="https://atelierdecodigo.com/posts/consola-script-escribir-codigo.html">scripts</a> en lugar de hacerlo solo en la consola permite conservar el proceso completo. Usar nombres claros para objetos y funciones facilita la lectura. Agregar comentarios ayuda a entender por qué se tomó cierta decisión y no otra. Organizar el trabajo en <a href="https://atelierdecodigo.com/posts/proyectos-rstudio.html">proyectos</a> mantiene juntos los datos, el código y los resultados. Todas estas prácticas apuntan a lo mismo: que el análisis pueda ser retomado y entendido.</p>
<p>La reproducibilidad también se beneficia de la separación entre datos crudos y datos procesados. Mantener una versión original de los datos y realizar todas las transformaciones mediante código evita errores difíciles de detectar. Si algo cambia en los datos de entrada (por ejemplo, si agregaste sujetos a tu toma de datos), el análisis puede volver a ejecutarse sin necesidad de rehacer pasos de forma manual.</p>
<p>Otro aspecto clave es la automatización. Cuando los resultados se generan a partir del código, no hace falta copiar valores de un lado a otro. Gráficos, tablas y estadísticas se producen directamente desde los scripts. Esto reduce errores y asegura que los resultados estén alineados con los datos y las decisiones actuales del análisis.</p>
<p>Herramientas como RStudio facilitan este enfoque. El trabajo con <a href="https://atelierdecodigo.com/posts/proyectos-rstudio.html">proyectos</a>, el uso de <a href="http://atelierdecodigo.com/posts/consola-script-escribir-codigo.html">scripts</a> y la posibilidad de integrar código y texto en documentos reproducibles como <a href="https://macarenaquiroga.com/post/guia-hiper-basica-a-rmarkdown/">RMarkdown</a> permiten construir análisis que se ejecutan de principio a fin. El resultado es un trabajo más transparente, tanto para quien lo realiza como para quien lo lee.</p>
<p>La reproducibilidad no es un objetivo abstracto ni una exigencia externa. Tiene efectos muy concretos en el trabajo cotidiano. Ahorra tiempo cuando hay que corregir algo, permite retomar análisis después de semanas o meses y facilita el intercambio con otras personas. Incluso cuando el análisis no se va a compartir públicamente, trabajar de forma reproducible mejora la calidad del proceso.</p>
<p>Programar bien no garantiza por sí solo la reproducibilidad, pero crea las condiciones para que sea posible. Escribir código legible, ordenado y documentado convierte al análisis en un objeto que puede revisarse, discutirse y mejorarse. En ese sentido, las buenas prácticas de programación forman parte del trabajo científico tanto como la formulación de preguntas o la interpretación de resultados.</p>
<p>En los próximos textos de esta serie, vamos a seguir profundizando en herramientas concretas que ayudan a sostener esta forma de trabajar, desde la organización del código hasta el uso de control de versiones.</p>



 ]]></description>
  <guid>https://atelierdecodigo.com/posts/reproducibilidad.html</guid>
  <pubDate>Thu, 22 Jan 2026 03:00:00 GMT</pubDate>
</item>
<item>
  <title>Trabajar con proyectos en RStudio: ordenar el trabajo desde el inicio</title>
  <link>https://atelierdecodigo.com/posts/proyectos-rstudio.html</link>
  <description><![CDATA[ 




<p>Cuando se empieza a usar R, es común trabajar con archivos sueltos: un script por acá, un archivo de datos por allá, resultados guardados en el escritorio o en carpetas poco claras. Ese modo de trabajo suele funcionar al principio, pero se vuelve frágil cuando el análisis crece, cuando pasa el tiempo o cuando otra persona necesita entender qué se hizo (¡o vos en el futuro!). En ese punto aparece una herramienta clave de RStudio: los proyectos.</p>
<p>Un proyecto en RStudio es una forma de organizar el trabajo en una carpeta principal. Todo lo que pertenece a un análisis o proyecto determinado vive dentro de ese espacio: scripts, datos, gráficos, tablas y documentos. Al abrir un proyecto, RStudio sabe dónde está parado y trabaja siempre desde ese lugar. Esto evita uno de los problemas más frecuentes al empezar: los errores de <a href="https://dev.to/devjohanadrian/rutas-relativas-y-absolutas-en-programacion-15nh">rutas absolutas o relativas</a>, y archivos que “no se encuentran”.</p>
<p>Desde un punto de vista conceptual, trabajar con proyectos ayuda a hacer explícita la estructura del trabajo. El análisis deja de ser una sucesión de comandos dispersos y pasa a tener un marco claro. Cada archivo cumple una función y su ubicación tiene sentido. Además, el proyecto guarda información sobre el <a href="http://atelierdecodigo.com/posts/entorno-desarrollo-integrado-ide.html">entorno de trabajo</a>, lo que hace más fácil retomar el análisis después de un tiempo sin tener que reconstruir todo desde cero.</p>
<p>Los proyectos también favorecen la reproducibilidad. Si todo está dentro de una misma carpeta, es más sencillo mover el trabajo a otra computadora o compartirlo, por ejemplo a través de un repositorio de Github. No hace falta reescribir rutas absolutas ni ajustar configuraciones cada vez. RStudio se encarga de abrir el proyecto y dejar todo listo para continuar.</p>
<section id="cómo-crear-un-proyecto-en-rstudio-paso-a-paso" class="level3">
<h3 class="anchored" data-anchor-id="cómo-crear-un-proyecto-en-rstudio-paso-a-paso">Cómo crear un proyecto en RStudio paso a paso</h3>
<ol type="1">
<li><p>Abrí RStudio.</p></li>
<li><p>En el menú superior, hacé clic en <strong>File</strong> y luego en <strong>New Project….</strong></p></li>
<li><p>RStudio va a ofrecer tres opciones. Para empezar, la más simple es <strong>New Directory</strong>.</p></li>
<li><p>Elegí <strong>New Project</strong>.</p></li>
<li><p>Indicá el nombre del proyecto y la ubicación donde querés que se cree la carpeta.</p></li>
<li><p>Hacé clic en <strong>Create Project</strong>.</p></li>
</ol>
<p>RStudio va a crear una carpeta con ese nombre y abrir automáticamente el proyecto. A partir de ese momento, cada vez que abras ese archivo de proyecto, identificado por la extensión <code>.Rproj</code>, RStudio va a trabajar desde esa carpeta. Lo vas a ver en la esquina superior derecha, al lado de un cubo celeste con una “R”:</p>
<p><img src="https://atelierdecodigo.com/posts/images/CleanShot 2026-01-18 at 20.09.35@2x.png" class="img-fluid"></p>
</section>
<section id="qué-cambia-al-trabajar-dentro-de-un-proyecto" class="level3">
<h3 class="anchored" data-anchor-id="qué-cambia-al-trabajar-dentro-de-un-proyecto">Qué cambia al trabajar dentro de un proyecto</h3>
<p>Una vez que el proyecto está creado, conviene adoptar algunas prácticas simples. Guardar los scripts dentro de la carpeta del proyecto, por ejemplo en una subcarpeta llamada <code>scripts</code>. Colocar los datos en otra carpeta, como <code>data</code>. Guardar gráficos o tablas en carpetas específicas. Esta organización no es obligatoria, pero ayuda a que el trabajo sea más legible.</p>
<p>Otro cambio importante es el uso de rutas relativas. Dentro de un proyecto, cuando se hace referencia a un archivo, se lo nombra en relación con la carpeta del proyecto. Por ejemplo, <code>data/encuesta.csv</code>. Esto funciona siempre que el proyecto esté abierto y evita errores cuando el análisis se mueve de lugar.</p>
<p>RStudio también muestra el nombre del proyecto activo en la esquina superior derecha. Ese detalle visual sirve como recordatorio constante de en qué contexto se está trabajando. Abrir un script sin abrir el proyecto puede generar confusión, por lo que conviene acostumbrarse a iniciar el trabajo siempre desde el archivo <code>.Rproj</code>.</p>
<p>Por último: una recomendación personal. Antes de terminar de trabajar o de cerrar el archivo, probá reiniciar la sesión de RStudio (en la barra superior, <strong>Session</strong> y después <strong>Restart R</strong>), y probá ejecutar todo el código desde cero. Si todo sale bien, entonces el código está limpio y listo para ser guardado. Pero si modificaste algo (por ejemplo en la consola) que rompió la continuidad del código, va a saltar un error. Y creeme que es mejor corregirlo en el momento que al día siguiente (o meses o años después…).</p>
</section>
<section id="proyectos-como-hábito-de-trabajo" class="level3">
<h3 class="anchored" data-anchor-id="proyectos-como-hábito-de-trabajo">Proyectos como hábito de trabajo</h3>
<p>Trabajar con proyectos no requiere conocimientos avanzados ni cambia la forma de escribir código. Cambia, sobre todo, la forma de organizarlo. Incorporar este hábito desde el inicio ahorra tiempo, reduce errores y hace que el análisis sea más fácil de entender, incluso para quien lo hizo.</p>
<p>En el próximo post de esta serie vamos a dar un paso más y explicar cómo conectar un proyecto de RStudio con un sistema de control de versiones. Eso permite llevar un registro de cambios, volver a estados anteriores del trabajo y colaborar de manera más ordenada.</p>


</section>

 ]]></description>
  <guid>https://atelierdecodigo.com/posts/proyectos-rstudio.html</guid>
  <pubDate>Thu, 22 Jan 2026 03:00:00 GMT</pubDate>
</item>
<item>
  <title>Empezar con R: instalación y primeros pasos</title>
  <link>https://atelierdecodigo.com/posts/instalar-r-rstudio.html</link>
  <description><![CDATA[ 




<p>Empezar con R suele generar dudas muy concretas. Qué hay que instalar, en qué orden, para qué sirve cada cosa. Antes de escribir una sola línea de código, conviene aclarar este punto, porque R funciona a partir de varias piezas que se combinan entre sí. La buena noticia es que el proceso de instalación es sencillo y solo hay que hacerlo una vez.</p>
<p>El primer paso es instalar R. R es el lenguaje de programación propiamente dicho. Para hacerlo, hay que ir al sitio oficial del proyecto <a href="https://cran.r-project.org">CRAN</a>, y elegir el archivo instalador que corresponda a nuestro sistema operativo (Windows, macOS o Linux). Al hacer clic, accedemos a las instrucciones específicas para cada caso.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://atelierdecodigo.com/posts/images/CleanShot 2026-01-20 at 17.27.03.png" class="img-fluid figure-img"></p>
<figcaption>Instalar R desde CRAN</figcaption>
</figure>
</div>
<p>Técnicamente podríamos usar R directamente desde ese software que acabamos de instalar, en Windows y en macOS. Sin embargo, no es una interfaz gráfica muy amigable, por lo que la mayoría de las personas usa otros <a href="http://atelierdecodigo.com/posts/entorno-desarrollo-integrado-ide.html">entornos</a> como RStudio, VSCode o Positron. Si recién estamos empezando, es preferible usar RStudio, porque la mayoría de los tutoriales van a mostrar imágenes de ese entorno.</p>
<p>Como mencionamos <a href="http://atelierdecodigo.com/posts/entorno-desarrollo-integrado-ide.html">en un post anterior</a>, RStudio es un programa independiente que se instala por separado. Es una interfaz gráfica (técnicamente, un entorno de desarrollo integrado) que facilita la interacción entre el usuario y el lenguaje de programación R. Para instalarlo, hay que ir al sitio de <a href="https://posit.co/download/rstudio-desktop">RStudio</a> y descargar la versión gratuita. Como se ve en la imagen, también podemos instalar R desde aquí, pero si ya lo instalamos desde CRAN no es necesario volver a instalarlo.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://atelierdecodigo.com/posts/images/CleanShot 2026-01-20 at 17.29.28.png" class="img-fluid figure-img"></p>
<figcaption>Instalar RStudio.</figcaption>
</figure>
</div>
<p>Al abrir RStudio por primera vez, este detecta automáticamente la instalación de R y queda listo para usar. A partir de ese momento, RStudio se convierte en el espacio principal de trabajo.</p>
<p>Con R y RStudio instalados, ya es posible escribir y ejecutar código. El siguiente paso habitual es instalar paquetes, que son agregados que amplían las capacidades de R. Uno de los más usados es el Tidyverse, un conjunto de paquetes pensados para trabajar con datos de manera ordenada y legible (podés leer más sobre qué son los paquetes <a href="http://atelierdecodigo.com/posts/r-base-tidyverse.html">acá</a>).</p>
<p>Instalar un paquete en R se hace escribiendo una instrucción en la consola. En el caso del Tidyverse, el comando es:</p>
<p><code>install.packages("tidyverse")</code></p>
<p>Una vez que escribimos el código, debemos ejecutarlo (control+Enter o el ícono de “Run”). Este paso requiere conexión a internet y puede demorar unos minutos, porque el Tidyverse incluye varios paquetes. Van a aparecer muchos mensajes de colores en la consola: eso es normal (a menos que aparezca algo que diga “Warning” o “Error”). La instalación se hace una sola vez. Una vez instalado, para usarlo en una sesión de trabajo hay que cargarlo con:</p>
<p><code>library(tidyverse)</code></p>
<p>Esta diferencia entre instalar y cargar suele confundir al principio. Instalar descarga el paquete en la computadora. Cargar lo pone a disposición en la sesión actual de R. Cada vez que se inicia una sesión nueva y se quiere usar el Tidyverse, hay que volver a ejecutar <code>library(tidyverse)</code>.</p>
<p>Después de cargarlo, R muestra algunos mensajes en la consola indicando qué paquetes se activaron. A partir de ese momento, funciones como <code>ggplot</code>, <code>mutate</code> o <code>filter</code> quedan disponibles. No hace falta entenderlas todas de inmediato. Lo importante es saber que forman parte de un mismo ecosistema y que comparten una lógica común.</p>
<p>Un punto práctico para quienes empiezan es verificar que todo esté funcionando. Por ejemplo, escribir una línea simple como:</p>
<p><code>ggplot(mtcars, aes(x = mpg, y = wt)) + geom_point()</code></p>
<p>Si aparece un gráfico, la instalación fue exitosa. No importa si todavía no se entiende el código. Eso se irá trabajando más adelante.</p>
<p>Instalar R, RStudio y el Tidyverse marca el inicio del trabajo. A partir de ahí, aprender R implica familiarizarse con <a href="http://atelierdecodigo.com/posts/entorno-desarrollo-integrado-ide.html">el entorno</a>, con la escritura de <a href="http://atelierdecodigo.com/posts/consola-script-escribir-codigo.html">scripts</a> y con la lectura del código. Tener estas herramientas bien instaladas y funcionando evita muchos problemas innecesarios y permite concentrarse en lo más importante: entender qué hace el código y cómo usarlo para analizar datos.</p>
<p>En los próximos posts de esta serie vamos a ir desarmando estas piezas con más detalle, para que el paso inicial se transforme en una base sólida de trabajo.</p>



 ]]></description>
  <guid>https://atelierdecodigo.com/posts/instalar-r-rstudio.html</guid>
  <pubDate>Thu, 22 Jan 2026 03:00:00 GMT</pubDate>
</item>
<item>
  <title>Consola y script: dos formas de escribir código en R</title>
  <link>https://atelierdecodigo.com/posts/consola-script-escribir-codigo.html</link>
  <description><![CDATA[ 




<p>Cuando se abre R o RStudio por primera vez, la consola suele ser el punto de partida. Es la ventana donde aparece el símbolo <code>&gt;</code> y donde se pueden escribir instrucciones directamente. Se escribe una línea de código, se presiona Enter y R responde. Esa respuesta puede ser un número, una tabla, un mensaje o un gráfico. La consola sirve, básicamente, para decirle a R qué hacer y ver el resultado en el momento.</p>
<p><img src="https://atelierdecodigo.com/posts/images/CleanShot 2026-01-18 at 19.40.28@2x.png" class="img-fluid" alt="Imagen de una consola vacía."></p>
<p>La consola es útil para acciones rápidas. Por ejemplo, calcular un promedio, ver el contenido de un objeto o probar si una función hace lo que esperamos. También es común usarla para pequeños ensayos mientras se aprende. El problema es que lo que se escribe en la consola no queda guardado de forma ordenada. Si se cierra R o se reinicia la sesión, ese recorrido se pierde. Incluso con la sesión abierta, revisar qué se hizo hace un rato puede resultar confuso.</p>
<p>El script cumple otra función. Un script es un archivo donde se escribe código para guardarlo. En RStudio suele tener extensión <code>.R</code> y se abre en el panel del editor (pueden ir a <code>File</code>, <code>New File</code>, <code>R Script</code> o hacer click en el ícono con una cruz verde). Allí se pueden escribir muchas líneas de código, agregar comentarios y organizar el análisis paso a paso. Escribir en un script no ejecuta el código automáticamente. Cada línea o bloque se corre solo cuando se lo indica, ya sea con el botón que dice “Run”, o con control+Enter.</p>
<p><img src="https://atelierdecodigo.com/posts/images/CleanShot 2026-01-18 at 19.45.25@2x.png" class="img-fluid" alt="Imagen de un script vacío."></p>
<p>Esta diferencia es importante. El script permite separar dos momentos: escribir y ejecutar. Primero se escribe el código con calma. Después se decide qué ejecutar y cuándo. Esto hace que el trabajo sea más ordenado y más fácil de retomar. Si se vuelve a abrir el archivo días o semanas después, el código sigue ahí, en el orden en que fue pensado.</p>
<p>Un uso muy habitual es combinar ambos espacios. La consola se usa para probar algo rápido. Si ese código resulta útil, se copia o se escribe directamente en el script. De ese modo, el script va quedando como el registro principal del trabajo, mientras que la consola funciona como un espacio de prueba.</p>
<p>RStudio facilita esta forma de trabajar. Desde el script se puede ejecutar el código y el resultado aparece en la consola, pero el código quedará guardado en el archivo del script. Esta dinámica es especialmente útil cuando el análisis tiene varios pasos o cuando se quiere compartir el trabajo con otras personas.</p>
<p>En términos prácticos, una buena regla inicial es la siguiente: la consola sirve para probar y explorar; el script sirve para guardar y organizar. No hace falta elegir uno u otro de manera excluyente. Lo importante es entender qué aporta cada espacio y usarlo de forma consciente.</p>
<p>Aprender a escribir en scripts desde el principio ahorra tiempo más adelante. Permite corregir errores con facilidad, repetir análisis sin empezar de cero y entender mejor qué se hizo en cada etapa. Para quienes recién empiezan, esta diferencia suele marcar un antes y un después en la forma de trabajar con R.</p>



 ]]></description>
  <guid>https://atelierdecodigo.com/posts/consola-script-escribir-codigo.html</guid>
  <pubDate>Wed, 21 Jan 2026 03:00:00 GMT</pubDate>
</item>
<item>
  <title>R base, paquetes y Tidyverse: de qué hablamos cuando usamos R</title>
  <link>https://atelierdecodigo.com/posts/r-base-tidyverse.html</link>
  <description><![CDATA[ 




<p>Cuando empezamos a trabajar con R, una de las primeras expresiones que aparecen es “R base”. No, mentira: cuando empezamos a trabajar con R no tenemos idea de lo que estamos haciendo. Copiamos el código de los cursos que estamos haciendo o de los libros o tutoriales que estamos siguiendo. Es posible que esos materiales contengan información sobre la fuente de esas funciones, pero como aprendices nuestra <a href="https://es.wikipedia.org/wiki/Memoria_de_trabajo">memoria de trabajo</a> está un poco saturada y seguramente no le hayamos prestado atención.</p>
<p>A medida que vamos incorporando los conceptos y automatizando el ritmo de trabajo, podemos empezar a prestar atención a la teoría. Y vemos que surgen estos conceptos: R base, paquetes, librerías, Tidyverse. Estas palabras circulan con naturalidad en tutoriales, clases y foros, aunque no siempre se explicita qué significan ni cómo se relacionan entre sí. Sin embargo, entender esta arquitectura es clave para poder leer código con mayor autonomía y para tomar decisiones informadas sobre cómo trabajar con datos.</p>
<p><strong>R base</strong> refiere al conjunto de funcionalidades que vienen incluidas cuando se instala R. Incluye el lenguaje propiamente dicho, un conjunto amplio de funciones fundamentales y algunos paquetes básicos que se cargan automáticamente. Operaciones aritméticas, creación de objetos, manejo básico de vectores y data frames, funciones como <code>mean()</code>, <code>sum()</code>, <code>plot()</code> o <code>summary()</code>, forman parte de este núcleo. R base define la gramática mínima del lenguaje y establece las reglas que permiten que todo lo demás funcione.</p>
<p>Trabajar solo con R base es posible, y de hecho durante muchos años fue la forma estándar de usar R. Sin embargo, ese núcleo está pensado para ser extendido. R fue diseñado desde el inicio como un lenguaje<sup>1</sup>, capaz de incorporar nuevas funcionalidades sin modificar su estructura central. Esa extensibilidad se materializa a través de los paquetes.</p>
<p>Un paquete es un conjunto organizado de funciones, datos y documentación que se puede descargar e incorporar a una sesión de R. Cada paquete responde a una necesidad específica: análisis estadístico particular, visualización, manejo de textos, trabajo con encuestas, modelos avanzados o formatos de datos concretos. Técnicamente, instalar un paquete implica descargarlo en la computadora; usarlo implica cargarlo en la sesión activa. Conceptualmente, usar un paquete implica adoptar una forma particular de resolver problemas analíticos. Hay paquetes de todos los gustos y colores: algunos se enfocan en funciones, otros en datos. Dado que hay muchos paquetes distintos que realizan las mismas acciones, en el último tiempo se ha insistido bastante en <a href="https://ropensci.org/blog/2021/11/16/how-to-cite-r-and-r-packages/">la importancia de citar los paquetes utilizados en el análisis de datos</a>, con lo cual han surgido, no sin cierta ironía, <a href="https://pakillo.github.io/grateful/">paquetes que facilitan el citado de los paquetes</a>.</p>
<p>Los paquetes pueden pensarse como cristalizaciones de prácticas de investigación. Quien desarrolla un paquete toma decisiones sobre qué operaciones facilitar, cómo nombrarlas, qué estructuras de datos privilegiar y qué supuestos dar por sentados. Cuando usamos una función de un paquete, no solo estamos reutilizando código, sino también incorporando una cierta manera de pensar el análisis. Si bien es difícil conocer a fondo el paquete del cual estamos tomando una función, siempre es una buena práctica leer <a href="https://www.r-project.org/other-docs.html">su documentación</a>.</p>
<p>En este punto suele aparecer otra fuente de confusión: el término “librería”. En R, librería se usa para referirse al lugar donde están instalados los paquetes en el sistema, y también, por extensión, al acto de cargarlos mediante la función <code>library()</code>. En la práctica cotidiana, hablar de paquetes y librerías suele ser intercambiable, aunque desde un punto de vista técnico no sean exactamente lo mismo. Lo importante es entender que R base se amplía mediante paquetes que se cargan según las necesidades del análisis.</p>
<p>Dentro de este universo de paquetes, hay uno que ocupa un lugar particular: el <a href="https://tidyverse.org/">Tidyverse</a>. El Tidyverse no es un paquete único, sino un conjunto de paquetes diseñados para trabajar de manera coherente entre sí. Incluye herramientas muy utilizadas para la manipulación de datos, la visualización y la importación de archivos, como <code>dplyr</code>, <code>ggplot2</code>, <code>tidyr</code>, <code>readr</code> y <code>stringr</code>, entre otros. Todos comparten una filosofía común y una sintaxis relativamente consistente, que se encuentra en el libro <a href="https://es.r4ds.hadley.nz/"><em>R para ciencia de datos</em></a> [<a href="https://r4ds.hadley.nz/"><em>R for Data Science</em></a>] de Hadley Wickham y Garrett Gloremund.</p>
<p>La propuesta central del Tidyverse es organizar el trabajo con datos a partir de principios claros. Uno de los más conocidos es el concepto de datos “ordenados” (<em>tidy data</em>), donde cada variable ocupa una columna, cada observación una fila y cada tipo de unidad analítica una tabla.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://atelierdecodigo.com/posts/images/CleanShot 2026-01-20 at 17.09.46.png" class="img-fluid figure-img"></p>
<figcaption>Imagen tomada del libro “R para Ciencia de Datos”, de Hadley Wickham y Garrett Grolemund.</figcaption>
</figure>
</div>
<p>Este principio, que puede parecer puramente técnico, tiene implicancias analíticas importantes, porque fuerza a explicitar qué se considera una variable, qué cuenta como observación y cómo se estructuran los datos. Esto puede cambiar no solamente entre conjuntos de datos, sino también entre análisis y mismo entre funciones. Por ejemplo, una función que haga un análisis estadístico de comparación de grupos puede tomar la variable de agrupación de una sola columna o puede pedir que cada grupo tenga su propia columna.</p>
<p>Otro rasgo distintivo del Tidyverse es su énfasis en la legibilidad del código. Las funciones suelen tener nombres verbales, los argumentos privilegian la claridad y el uso del operador <code>%&gt;%</code> propone una lectura secuencial de las operaciones. Para quienes vienen de tradiciones donde la interpretación de textos y la explicitación de procedimientos son centrales, esta orientación resulta especialmente atractiva. El código se presenta como una secuencia de transformaciones que puede leerse casi como una narración del análisis (<a href="https://www.reddit.com/r/rstats/comments/vbd6jq/piping_in_r_is_like_baking/#lightbox">¡o como una receta de cocina!</a>)<sup>2</sup>.</p>
<p>Esto no significa que el Tidyverse reemplace a R base. De hecho, se apoya constantemente en él. Muchas funciones del Tidyverse envuelven o reorganizan funcionalidades existentes en R base, ofreciendo una interfaz distinta. Elegir trabajar con R base, con paquetes específicos o con el Tidyverse no es una cuestión de corrección, sino de enfoque. Cada opción implica adoptar ciertas convenciones y renunciar a otras. También tiene que ver con conocer a la audiencia de nuestro código: determinados paquetes suelen ser más <em>famosos</em> en determinados ámbitos y eso puede privilegiar nuestra decisión de usarlos frente a otras alternativas menos conocidas. En definitiva, se trata de usar el <em>lenguaje</em> de la forma que facilitará su comprensión.</p>
<p>Entender estas diferencias permite salir de una lógica puramente instrumental. Usar R no consiste solo en saber qué comando ejecutar, sino en comprender qué marco conceptual estamos utilizando al hacerlo. R base, los paquetes y el Tidyverse forman capas de un mismo lenguaje, que se combinan de maneras diversas según el problema de investigación, el tipo de datos y las preguntas que se quieren formular.</p>
<p>En los próximos textos de esta serie volveremos sobre estas herramientas con ejemplos concretos. La idea no será aprender listas de funciones, sino desarrollar criterios para leer código, reconocer estilos y elegir conscientemente cómo trabajar con R en contextos de investigación situados.</p>




<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Otra vez aparecen metáforas que acercan el lenguaje de programación a otras disciplinas. En este caso, pienso en <a href="https://books.google.com.ar/books?id=ISgIzxoFgikC&amp;printsec=copyright#v=onepage&amp;q&amp;f=false">la concepción modular de la mente</a>, de Jerry Fodor.↩︎</p></li>
<li id="fn2"><p>Acá hay que hacer una aclaración. El famoso operador <code>%&gt;%</code> (<em>pipe</em>) durante mucho tiempo fue sinónimo de Tidyverse aunque proviene del paquete específico <code>magrittr</code>. Sin embargo, la versión R 4.1.0 que salió en mayo del 2021 incorporó un operador similar, <code>|&gt;</code>, con lo cual la concatenación de funciones como la que se ve en ese simpático gif ya no es exclusiva de Tidyverse. En rigor de verdad, ambos operadores tienen funcionamientos distintos, por lo cual reemplazar el operador <code>%&gt;%</code> por <code>|&gt;</code> de forma masiva en nuestro código puede dar lugar a errores. Las diferencias pueden ser demasiado técnicas para alguien que recién está empezando, pero si les interesa pueden leer un poco <a href="https://tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/">acá</a>.↩︎</p></li>
</ol>
</section></div> ]]></description>
  <guid>https://atelierdecodigo.com/posts/r-base-tidyverse.html</guid>
  <pubDate>Tue, 20 Jan 2026 03:00:00 GMT</pubDate>
</item>
<item>
  <title>R para humanidades: ¿Por qué aprender a programar?</title>
  <link>https://atelierdecodigo.com/posts/r-humanidades-aprender.html</link>
  <description><![CDATA[ 




<p>Aprender a programar suele presentarse como una habilidad técnica, asociada un mercado laboral centrado en lo tecnológico. Para quienes venimos de las ciencias sociales y humanas, ese mundo nos puede resultar ajeno. Nuestro trabajo cotidiano tiene otra materialidad (¿textos?) y está atravesado por preguntas sobre el lenguaje, la interpretación, la construcción de categorías y la producción situada de conocimiento. Sin embargo, cada vez más surgen herramientas tecnológicas que permiten imbricar ambos mundos y cada vez más hay personas del mundo de la lingüística, la sociología o las ciencias políticas trabajando con código y ciencias de datos.</p>
<p>Nos solemos detener a pensar qué nos aporta la programación a quienes trabajamos en estas áreas, pero, ¿qué podemos aportar nosotros y nosotras a ese mundo? ¿Qué nuevas miradas podemos brindar sobre la tecnología? Hay una que nos parece central, que hemos mencionado varias veces porque está en el fondo de nuestra experiencia: programar es escribir. Más allá de las obvias asociaciones entre un “lenguaje natural” y un “lenguaje de programación”, creemos que hay fundamentalmente una dimensión textual que comparten tanto los <em>textos</em> como los <em>scripts</em>. En ese marco, proponemos ver a la programación no tanto como una destreza instrumental, sino más bien como una práctica de escritura y de análisis que dialoga con preocupaciones ya conocidas.</p>
<p>Programar implica escribir instrucciones en un lenguaje formal, pero también leerlas, interpretarlas y revisarlas. Un <a href="https://atelierdecodigo.com/posts/consola-script-escribir-codigo.html">script</a> en R no es solo una secuencia de comandos que “funciona” o “no funciona”: es un texto que condensa decisiones analíticas, supuestos teóricos y recortes metodológicos. ¿Por dónde empezamos? ¿Cuánto nos detenemos en un análisis descriptivo o cuánto en un análisis inferencial? ¿Escribimos en soledad o esperamos que alguien más nos lea? ¿Comentamos nuestro texto?</p>
<p>Del mismo modo que analizamos un texto académico preguntándonos qué conceptos usa, qué deja afuera o cómo organiza su argumento, el código también puede leerse críticamente. Aprender a programar en R, entonces, abre la posibilidad de pensar con datos de una manera explícita y revisable.</p>
<p>R es especialmente interesante para este cruce porque <a href="https://atelierdecodigo.com/posts/r-lenguaje-programacion.html">nació y se desarrolló en el ámbito académico</a>. Su uso extendido en estadística, lingüística, sociología, psicología y ciencias de la educación no es casual. La lógica del lenguaje favorece un trabajo exploratorio y reflexivo con los datos, donde cada paso del análisis puede quedar registrado. Además, su ecosistema de paquetes refleja debates y tradiciones disciplinares concretas, que se materializan en funciones, argumentos y estructuras de datos. Paradójicamente, muchas personas ven el debate R vs Python como un debate de academia vs industria (mayoritariamente por quienes vienen de la industria y tienen sesgos negativos hacia el trabajo académico).</p>
<p>Algo de esto se ve en los materiales de aprendizaje de los cursos: la amplia mayoría se enfocan en instrucciones sobre cómo realizar una determinada tarea, pero pocas veces hay explicaciones sobre el funcionamiento intrínseco del lenguaje. De hecho, pocas veces se resalta el aspecto <em>lingüístico</em> de un lenguaje de programación, a pesar de heredar atributos como la <a href="https://es.wikipedia.org/wiki/Sintaxis_(lenguajes_de_programaci%C3%B3n)">sintaxis</a> o la <a href="https://es.wikipedia.org/wiki/Sem%C3%A1ntica_de_lenguajes_de_programaci%C3%B3n">semántica</a>. Quienes venimos de la lingüística y tenemos incorporada la mirada sobre los aspectos formales o combinatorios de las estructuras tenemos una ventaja que no suele mencionarse. Más bien, lo contrario: quienes vienen de las ciencias sociales y humanas suelen sentir que su forma de pensar es distinta a la necesaria para adentrarse al mundo de la tecnología (sobre eso charlamos en el <a href="https://www.youtube.com/watch?v=t4f76etAF0Q">#LatinR2024)</a>.</p>
<p>Desde nuestra perspectiva, aprender a programar no significa abandonar prácticas propias de otras áreas. Al contrario, implica extenderlas a un nuevo tipo de texto. El código se convierte en un espacio donde se articulan teoría, método y datos. Herramientas como RStudio, y prácticas como el uso de scripts reproducibles o documentos en <a href="https://macarenaquiroga.com/post/guia-hiper-basica-a-rmarkdown/">R Markdown</a>, refuerzan esta idea al integrar código, texto y resultados en un mismo soporte.</p>
<p>En el cierre de esta reflexión, vale insistir en una idea central: la programación es una práctica situada. Se aprende en contextos específicos, para responder a preguntas concretas, con tradiciones disciplinares determinadas. Aprender R desde las humanidades y las ciencias sociales no implica adoptar sin más un lenguaje ajeno, sino apropiarse de él, leerlo críticamente y usarlo para pensar problemas propios. Programar, en este sentido, es otra forma de escribir, analizar y producir conocimiento.</p>



 ]]></description>
  <guid>https://atelierdecodigo.com/posts/r-humanidades-aprender.html</guid>
  <pubDate>Sun, 18 Jan 2026 03:00:00 GMT</pubDate>
</item>
<item>
  <title>Los entornos de desarrollo integrado (o IDE, para los amigos)</title>
  <link>https://atelierdecodigo.com/posts/entorno-desarrollo-integrado-ide.html</link>
  <description><![CDATA[ 




<p>Cuando alguien comienza a programar, una de las primeras confusiones habituales tiene que ver con el entorno de trabajo. ¿Dónde “vive” el código? ¿Se escribe en un archivo de texto común? ¿Se ejecuta desde una consola (y qué es una consola)? ¿Es lo mismo R que RStudio? ¿Tengo que <a href="http://atelierdecodigo.com/posts/instalar-r-rstudio.html">instalar</a> las dos cosas? ¿En qué orden? Estas preguntas no son menores, porque remiten a una distinción clave: la diferencia entre un lenguaje de programación y el entorno en el que ese lenguaje se usa. En ese punto aparece la noción de <strong>IDE</strong>, sigla de <em>Integrated Development Environment</em>, o entorno de desarrollo integrado.</p>
<p>Un IDE es un programa que reúne en un mismo espacio varias herramientas necesarias para programar. En términos generales, combina al menos cuatro componentes: un editor de código, una consola donde se ejecutan instrucciones, herramientas para explorar archivos y objetos, y ayudas para la escritura y lectura del código. El IDE no reemplaza al lenguaje de programación, sino que ofrece una interfaz gráfica que facilita su uso. R sigue siendo R, con su sintaxis y sus reglas, independientemente del IDE que se utilice. Sin embargo, la experiencia de trabajo cambia de manera sustantiva según el entorno elegido.</p>
<p>Existen IDEs ampliamente utilizados en distintos lenguajes. <a href="https://code.visualstudio.com/">Visual Studio Code</a> es uno de los más populares en la actualidad y se usa para trabajar con múltiples lenguajes, desde R y Python hasta JavaScript. <a href="https://eclipseide.org/">Eclipse</a> tiene una larga tradición en el desarrollo en Java. <a href="https://www.spyder-ide.org/download">Spyder</a> es frecuente en el ecosistema Python, especialmente en contextos científicos. En el caso de R, el IDE más extendido es <strong>RStudio</strong>, que fue diseñado específicamente para trabajar con este lenguaje y con las prácticas habituales del análisis de datos. En los últimos años también apareció <a href="https://posit.co/products/ide/positron/">Positron</a>, un IDE desarrollado por <a href="https://posit.co/">Posit</a> que retoma muchas de las ideas de RStudio y las articula con una lógica más generalista, orientada al trabajo con múltiples lenguajes. Sin embargo, en esta serie nos detendremos en <a href="https://posit.co/products/open-source/rstudio/?sid=1">RStudio</a> porque sigue siendo el entorno más extendido en el uso académico de R y porque su diseño está profundamente alineado con prácticas habituales de análisis, enseñanza y escritura reproducible en este lenguaje. Y también porque es al que estamos acostumbradas :)</p>
<p>RStudio se organiza en una interfaz que, a primera vista, puede resultar abrumadora: paneles, pestañas, botones, ventanas. Sin embargo, esa disposición responde a una lógica de trabajo que vale la pena comprender. En un panel suele encontrarse el editor de scripts, donde se escribe el código. En otro, la consola, que permite ejecutar líneas o bloques de código y ver inmediatamente sus resultados. Otros paneles muestran los objetos disponibles en la sesión, los archivos del proyecto, los gráficos generados o la documentación de las funciones. Esta organización no es decorativa. Propone una forma de pensar el trabajo con datos como una actividad distribuida entre escritura, ejecución, exploración y lectura. En <a href="https://macarenaquiroga.com/post/auxilio-tengo-datos-cuantitativos-y-ahora-qu-hago/">este post</a> hay una descripción sobre cómo se ve cada una de estas partes. Lo importante es reconocer cada una de las unidades de forma separada, porque eventualmente el usuario puede reorganizar el lugar de los paneles en su pantalla.</p>
<p>El editor de scripts ocupa un lugar central. Allí el código se presenta como un texto que puede leerse, revisarse y modificarse. RStudio ofrece ayudas como el resaltado de sintaxis, la indentación automática y el autocompletado, aunque lleva algo de tiempo entender estas funcionalidades e incorporarlas a la práctica cotidiana. Estas funciones no solo reducen errores técnicos, sino que facilitan la lectura del código. Colores, sangrías y sugerencias hacen visibles estructuras que, de otro modo, quedarían ocultas en una masa uniforme de caracteres. El IDE, en este sentido, actúa como un mediador que vuelve más legible el lenguaje. Un script es, en definitiva, un texto.</p>
<p>Podemos pensar el editor de scripts como un procesador de textos, del estilo de Word o GoogleDocs. El editor marcará con una cruz roja cuando haya algo que altere la sintaxis de R (al igual que los procesadores de texto subrayan palabras con errores ortográficos). Atender a los errores es una forma muy eficaz de entender cómo funciona la sintaxis de un lenguaje de programación.</p>
<p>En la consola podemos ejecutar funciones de forma directa, aunque no se guardarán a menos que las escribamos en el script (y esto puede traer problemas si perdemos el hilo de nuestro código). Trabajar con la consola puede ser útil cuando se está aprendiendo, porque habilita la prueba, el error y la reformulación constante, pero el hecho de que el código y sus resultados aparezcan en un mismo lugar puede dificultad la claridad de nuestro recorrido. El IDE no obliga a seguir un recorrido lineal, sino que acompaña procesos de ida y vuelta entre hipótesis, código y resultados.</p>
<p>Otro aspecto relevante de RStudio es su integración con proyectos. Trabajar en un proyecto (¡se viene un post al respecto!) implica organizar archivos, datos, scripts y resultados dentro de una estructura coherente. Esta práctica, que al comienzo puede parecer excesiva, se vuelve fundamental cuando los análisis crecen en complejidad o cuando se retoman después de un tiempo. El IDE facilita esta organización y, al hacerlo, promueve una forma más reflexiva y documentada de trabajar. El código deja de ser algo efímero que se ejecuta una vez y se pierde, para convertirse en un registro del proceso analítico. Esto, además, favorece la reproducibilidad, un aspecto crucial en la práctica científica.</p>
<p>RStudio también incorpora un acceso directo a la documentación, esto es, a la descripción y guía de uso de las funciones y paquetes. Al escribir una función, es posible consultar rápidamente qué hace, qué argumentos espera y qué devuelve. Por ejemplo, ejecutar <code>?summary</code> en la consola dará como resultado la guía específica de uso de esa función. Esta cercanía con la ayuda refuerza la idea de que programar implica leer tanto como escribir. Las funciones no se usan a ciegas, sino que se interpretan, se comparan y se eligen en función de lo que se quiere hacer con los datos. Nadie sabe de memoria, sino que constantemente acudimos a los materiales que produjeron quienes crearon estas funciones.</p>
<p>Es importante subrayar que aprender a usar un IDE no es un requisito previo para “saber programar”, pero sí forma parte de la alfabetización técnica que acompaña al aprendizaje del lenguaje. El IDE configura hábitos, modos de lectura y formas de organizar el trabajo. En ese sentido, no es neutral. RStudio, en particular, está diseñado para prácticas de análisis propias del trabajo académico: exploración de datos, escritura reproducible, combinación de código y texto, producción de gráficos y reportes.</p>
<p>Pensar el IDE como un simple soporte técnico puede llevar a subestimarlo. En realidad, funciona como un espacio de trabajo que materializa una cierta concepción de la programación. Para quienes se inician en R desde las ciencias sociales y humanas, entender qué es un IDE y cómo organiza la experiencia de programar ayuda a desarmar la idea de que el código es algo opaco o inaccesible. El entorno también se lee, se interpreta y se aprende a usar de manera situada.</p>
<p>En los próximos textos de esta serie, volveremos sobre RStudio con mayor detalle, observando cómo ciertas decisiones de interfaz dialogan con prácticas concretas de análisis. Comprender el entorno es un paso clave para empezar a pensar el código como un lenguaje con el que se trabaja, y no solo como una herramienta que se ejecuta.</p>



 ]]></description>
  <guid>https://atelierdecodigo.com/posts/entorno-desarrollo-integrado-ide.html</guid>
  <pubDate>Sat, 17 Jan 2026 03:00:00 GMT</pubDate>
</item>
<item>
  <title>R: un lenguaje que nació para pensar con datos</title>
  <link>https://atelierdecodigo.com/posts/r-lenguaje-programacion.html</link>
  <description><![CDATA[ 




<p>Cuando desde las ciencias sociales y humanas nos acercamos por primera vez a un lenguaje de programación, suele aparecer una sensación ambigua: curiosidad, interés y, al mismo tiempo, cierta cautela. Programar se asocia con frecuencia a una práctica técnica, distante de la lectura, el análisis discursivo o la reflexión teórica. Sin embargo, podemos elegir un punto de entrada diferente para aprender R. Su historia, sus usos y la comunidad que lo sostiene lo convierten en un lenguaje particularmente cercano a una mirada analítica sobre los datos y sobre las condiciones de producción del conocimiento.</p>
<p>R se originó en el ámbito de la estadística académica. A comienzos de la década de 1990, Ross Ihaka y Robert Gentleman, estadísticos de la Universidad de Auckland, desarrollaron R como una reimplementación libre del lenguaje S, utilizado desde los años setenta en investigación estadística. Desde ese momento inicial, R fue concebido como una herramienta para explorar datos, ensayar modelos y acompañar procesos de investigación científica. Esta procedencia ayuda a entender muchas de sus características actuales y también las prácticas que se consolidaron en torno a su uso.</p>
<p>Una de las notas distintivas de R es su orientación al análisis interactivo. El código se ejecuta de manera progresiva y permite un trabajo exploratorio con los datos: probar una operación, observar el resultado, ajustar la instrucción y volver a evaluar. Para quienes están habituados a construir análisis de forma iterativa, a partir de hipótesis provisorias y reformulaciones constantes, este modo de trabajo resulta especialmente familiar. Programar en R suele implicar sostener un proceso de exploración controlada, más que seguir un recorrido completamente predefinido.</p>
<p>Desde el punto de vista técnico, R se apoya fuertemente en el uso de funciones. La mayor parte de las operaciones se realizan aplicando funciones a objetos (de hecho, R es <a href="https://es.wikipedia.org/wiki/Programaci%C3%B3n_orientada_a_objetos">un lenguaje orientado a objetos</a>, al igual que Python). Una función puede entenderse como una operación formalizada que recibe uno o más argumentos, ejecuta una serie de pasos internos y devuelve un resultado. Calcular un promedio, transformar una variable, ajustar un modelo o producir un gráfico son ejemplos de tareas que se realizan mediante funciones. Leer código en R implica identificar qué funciones aparecen, qué argumentos reciben y qué tipo de objeto generan como salida.</p>
<p>Este énfasis en las funciones favorece una lectura atenta del código como si se tratara de un texto. Cada llamada a una función presenta una estructura relativamente estable: un nombre, paréntesis y argumentos que pueden estar explícitamente nombrados o quedar implícitos mediante valores por defecto. Para quienes tienen experiencia en el análisis de textos, esta sintaxis puede abordarse como un sistema de marcas que orienta la interpretación. Comprender por qué una función produce cierto resultado suele requerir detenerse en esos detalles y en los supuestos que la función incorpora.</p>
<p>Con el tiempo, los usos de R se expandieron de manera considerable. En la actualidad, se utiliza para análisis estadístico, modelado, visualización de datos, análisis de textos, estudios de redes sociales, trabajo con datos espaciales y experimentos en psicología y lingüística, entre muchos otros campos. Esta expansión se explica en gran medida por el sistema de paquetes. Un paquete es un conjunto organizado de funciones, datos y documentación que amplía las capacidades del lenguaje. R funciona así como un entorno en constante crecimiento, alimentado por contribuciones de distintas comunidades académicas. Para las ciencias sociales y humanas, este rasgo resulta especialmente relevante. Muchas de las herramientas disponibles en R fueron desarrolladas por investigadoras e investigadores que trabajan con problemas afines a los nuestros. Los paquetes orientados al análisis de encuestas, textos, corpus lingüísticos o datos longitudinales incorporan decisiones teóricas y metodológicas específicas. Al leer el código que utiliza estos paquetes, también se accede a esas decisiones: cómo se define una unidad de análisis, qué operaciones se consideran pertinentes, qué supuestos se adoptan sobre los datos.</p>
<p>En este sentido, R puede pensarse como un lenguaje en el que se inscriben formas particulares de pensar y de investigar. La existencia de clases de objetos, la representación de los modelos como objetos que pueden ser examinados o la construcción de gráficos por capas organizan la relación entre quien analiza y el fenómeno analizado. Aprender R implica aprender a reconocer y a trabajar con esas mediaciones.</p>
<p>Por esta razón, en una serie dirigida a quienes se inician en la programación desde las ciencias sociales y humanas, resulta productivo presentar R como un lenguaje con historia, convenciones y comunidades de uso. Leer código en R, incluso cuando al principio lleva tiempo y esfuerzo, forma parte de una alfabetización técnica que dialoga con prácticas habituales de lectura e interpretación.</p>
<p>En los próximos textos de esta serie, iremos introduciendo fragmentos concretos de código. El objetivo será aprender a leerlos, descomponerlos y comprender qué están haciendo y qué están diciendo. Programar en R, desde nuestras disciplinas, implica incorporar una nueva forma de escritura y de producción de conocimiento situado.</p>



 ]]></description>
  <guid>https://atelierdecodigo.com/posts/r-lenguaje-programacion.html</guid>
  <pubDate>Sat, 17 Jan 2026 03:00:00 GMT</pubDate>
</item>
</channel>
</rss>
